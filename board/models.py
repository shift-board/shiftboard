import uuid

from django.contrib.auth.models import User
from django.db import models

# Create your models here.


class Image(models.Model):
    """
    A database model representing an image, containing a name and the BLOB of the actual image.

    This is a separate table to make indexing the other tables more efficient, and make extraction
    of one image simple and convenient. Each image in a Board or Post has a one-to-one relationship
    with an image stored in this table.

    Class Attributes
        name -> `CharField`: A charfield with max length 100 with the name of the image.
        photo -> `BinaryField`: A field with the stored image BLOB.
        uuid -> `UUIDField`: A unique, non-editable uuid4 UUID for each image, used to locate it.
    """

    name = models.CharField(max_length=100)
    photo = models.BinaryField()
    uuid = models.UUIDField(default=uuid.uuid4, unique=True, editable=False)

    def __str__(self):
        """Returns this image's uuid, which represents this image outside of this database."""
        return f'image: {self.uuid}'

class Board(models.Model):
    """
    A database model representing a board, where posts can be created and viewed.
    
    This model uses a `BinaryField` as opposed to an `ImageField` to store the background image of
    the board. While this is considered poor design in many cases, Heroku (the cloud provider
    to be used)'s ephemeral file system renders the file system impossible to use for dynamic
    storage. The is an issue because `ImageField`, which is a subclass of `FileField`, defaults to
    storing files on the file system under `MEDIA_ROOT`.

    As a workaround, this model stores the image as a BLOB in the actual database. While the
    database may inflate as a result, the preservation of the images is guaranteed.

    This board stores a many-to-many relationship to `django.contrib.auth.models.User`, the
    default `User` model generated by Django. Since Django offers a `ManyToManyField` as a field,
    an explicit lookup table is not necessary. Instead, users can be added to a board's
    `admin_users` field, and Django can use lookups across relationships to find all admin users for
    one specific board. Provided is an example:

    ```
    # generate and save mock users and boards. User is the default Django auth user.
    >>> u1 = User(username="shari", password="i love you") 
    >>> u1.save() # important! Save to generate an id
    >>> b1 = Board(title="shari fan club", description="a fan club for shari"...)
    >>> b1.save()

    # add u1 as admin user to b1
    >>> b1.admin_users.add(u1)

    # examine relationships
    >>> b1.admin_users.all()
    <QuerySet [<User: shari>]>
    >>> u1.board_set.all()
    <QuerySet [<Board: shari fan club>]>

    # find all boards where user 1 is an admin (lookup across relationship)
    >>> Board.objects.filter(admin_users__id=1) 
    <QuerySet [<Board: shari fan club>]>
    ```

    Further examples can be found at:
    https://docs.djangoproject.com/en/3.2/topics/db/examples/many_to_many/

    Class Attributes
        title -> `CharField`: A charfield with max length 100 containing the title of the board.
        description -> `CharField`: A charfield with max length 500 containing the title of the board.
        bg -> `OneToOneField`: A one-to-one relationship to the background image in the
            `Image` table.
        admin_users -> `ManyToManyField`: A field storing the many admin users of this board.
        uuid -> `UUIDField`: A unique, non-editable uuid4 UUID for each board.
    """
    # TODO: look into if we need a lookup table.

    title = models.CharField(max_length=100)
    description = models.CharField(max_length=200)
    bg = models.OneToOneField(Image, on_delete=models.CASCADE, blank=True)
    admin_users = models.ManyToManyField(User)
    uuid = models.UUIDField(default=uuid.uuid4, unique=True, editable=False)

    def __str__(self):
        """Returns the title and the UUID of this board."""
        return f'{self.title} - {self.uuid}'

class Post(models.Model):
    """
    A database model representing a post, where an image and message can be displayed.

    Each post belongs to a board. This model uses a `BinaryField` instead of an `ImageField` to
    work around Heroku (the planned cloud provider)'s ephemeral file system. Since images will
    be deleted if dynamically stored in the file system, they will be stored as BLOBs instead
    in the database. This way, the preservation and storage of the images is guaranteed. The
    database may inflate as a result, but that is acceptable for now.

    Class Attributes
        associated_board -> `ForeignKey`: The foreign key for the board that this post is on.
        name -> `CharField`: A charfield with max length 50 containing the author's name. Optional.
        message -> `CharField`: A charfield with max length 500 containing the specified message.
            Optional, but if not included, should contain a photo. Validation will be performed
            at the API level, as the database does not care if a post has no photo and description.
        photo -> `OneToOneField`: A one-to-one relationship to the posted image in the `Image`
            table. Optional, but if not included, should contain a description. Validation will be
            performed at the API level, as the database does not care if a post has no photo
            and description.
    """

    associated_board = models.ForeignKey(Board, on_delete=models.CASCADE)
    name = models.CharField(max_length=50, blank=True)
    message = models.CharField(max_length=500, blank=True)
    photo = models.OneToOneField(Image, on_delete=models.CASCADE, blank=True)

    def __str__(self):
        """Returns the board name, author name, and message of the post."""
        return f"{self.associated_board}: {self.name} -- {self.message}"

